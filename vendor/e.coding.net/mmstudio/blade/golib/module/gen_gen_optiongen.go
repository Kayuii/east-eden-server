// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package module

import (
	"time"

	"github.com/rs/zerolog/log"
)

type Options struct {
	InvokeTimeout        time.Duration
	InvokeQueueLen       int
	TimerDispatcherLen   int
	StrictOrderInvoke    bool
	DetectLoopInvoke     bool
	StepDetectLoopInvoke int
	LoopInvokeTrigger    func(cs []string)
	EnableGls            bool
	TerminateCleanQueue  bool
	LiveProbe            bool
	LiveNotifyInternal   time.Duration
	LiveTTL              time.Duration
	ShouldRestart        func(s Skeleton, errMsg string) bool
	PanicWithStack       bool
	CatchPanic           bool
	OnStopped            func(s Skeleton)
	OnTerminated         func(s Skeleton)
}

func (cc *Options) SetOption(opt Option) {
	_ = opt(cc)
}

func (cc *Options) ApplyOption(opts ...Option) {
	for _, opt := range opts {
		_ = opt(cc)
	}
}

func (cc *Options) GetSetOption(opt Option) Option {
	return opt(cc)
}

type Option func(cc *Options) Option

func WithOptionInvokeTimeout(v time.Duration) Option {
	return func(cc *Options) Option {
		previous := cc.InvokeTimeout
		cc.InvokeTimeout = v
		return WithOptionInvokeTimeout(previous)
	}
}
func WithOptionInvokeQueueLen(v int) Option {
	return func(cc *Options) Option {
		previous := cc.InvokeQueueLen
		cc.InvokeQueueLen = v
		return WithOptionInvokeQueueLen(previous)
	}
}
func WithOptionTimerDispatcherLen(v int) Option {
	return func(cc *Options) Option {
		previous := cc.TimerDispatcherLen
		cc.TimerDispatcherLen = v
		return WithOptionTimerDispatcherLen(previous)
	}
}
func WithOptionStrictOrderInvoke(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.StrictOrderInvoke
		cc.StrictOrderInvoke = v
		return WithOptionStrictOrderInvoke(previous)
	}
}
func WithOptionDetectLoopInvoke(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.DetectLoopInvoke
		cc.DetectLoopInvoke = v
		return WithOptionDetectLoopInvoke(previous)
	}
}
func WithOptionStepDetectLoopInvoke(v int) Option {
	return func(cc *Options) Option {
		previous := cc.StepDetectLoopInvoke
		cc.StepDetectLoopInvoke = v
		return WithOptionStepDetectLoopInvoke(previous)
	}
}
func WithOptionLoopInvokeTrigger(v func(cs []string)) Option {
	return func(cc *Options) Option {
		previous := cc.LoopInvokeTrigger
		cc.LoopInvokeTrigger = v
		return WithOptionLoopInvokeTrigger(previous)
	}
}
func WithOptionEnableGls(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.EnableGls
		cc.EnableGls = v
		return WithOptionEnableGls(previous)
	}
}
func WithOptionTerminateCleanQueue(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.TerminateCleanQueue
		cc.TerminateCleanQueue = v
		return WithOptionTerminateCleanQueue(previous)
	}
}
func WithOptionLiveProbe(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.LiveProbe
		cc.LiveProbe = v
		return WithOptionLiveProbe(previous)
	}
}
func WithOptionLiveNotifyInternal(v time.Duration) Option {
	return func(cc *Options) Option {
		previous := cc.LiveNotifyInternal
		cc.LiveNotifyInternal = v
		return WithOptionLiveNotifyInternal(previous)
	}
}
func WithOptionLiveTTL(v time.Duration) Option {
	return func(cc *Options) Option {
		previous := cc.LiveTTL
		cc.LiveTTL = v
		return WithOptionLiveTTL(previous)
	}
}
func WithOptionShouldRestart(v func(s Skeleton, errMsg string) bool) Option {
	return func(cc *Options) Option {
		previous := cc.ShouldRestart
		cc.ShouldRestart = v
		return WithOptionShouldRestart(previous)
	}
}
func WithOptionPanicWithStack(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.PanicWithStack
		cc.PanicWithStack = v
		return WithOptionPanicWithStack(previous)
	}
}
func WithOptionCatchPanic(v bool) Option {
	return func(cc *Options) Option {
		previous := cc.CatchPanic
		cc.CatchPanic = v
		return WithOptionCatchPanic(previous)
	}
}
func WithOptionOnStopped(v func(s Skeleton)) Option {
	return func(cc *Options) Option {
		previous := cc.OnStopped
		cc.OnStopped = v
		return WithOptionOnStopped(previous)
	}
}
func WithOptionOnTerminated(v func(s Skeleton)) Option {
	return func(cc *Options) Option {
		previous := cc.OnTerminated
		cc.OnTerminated = v
		return WithOptionOnTerminated(previous)
	}
}

func NewOptions(opts ...Option) *Options {
	cc := newDefaultOptions()
	for _, opt := range opts {
		_ = opt(cc)
	}
	if watchDogOptions != nil {
		watchDogOptions(cc)
	}
	return cc
}

func InstallOptionsWatchDog(dog func(cc *Options)) {
	watchDogOptions = dog
}

var watchDogOptions func(cc *Options)

func newDefaultOptions() *Options {

	cc := &Options{}

	for _, opt := range [...]Option{
		WithOptionInvokeTimeout(time.Duration(5) * time.Second),
		WithOptionInvokeQueueLen(defaultExecQueueLen),
		WithOptionTimerDispatcherLen(defaultExecQueueLen),
		WithOptionStrictOrderInvoke(true),
		WithOptionDetectLoopInvoke(true),
		WithOptionStepDetectLoopInvoke(5),
		WithOptionLoopInvokeTrigger(func(cs []string) {
			log.Error().Strs("chain", cs).Msg("skeleton got loop invoke")
		}),
		WithOptionEnableGls(true),
		WithOptionTerminateCleanQueue(true),
		WithOptionLiveProbe(false),
		WithOptionLiveNotifyInternal(time.Duration(5) * time.Second),
		WithOptionLiveTTL(time.Duration(20) * time.Second),
		WithOptionShouldRestart(func(s Skeleton, errMsg string) bool {
			return true
		}),
		WithOptionPanicWithStack(false),
		WithOptionCatchPanic(true),
		WithOptionOnStopped(nil),
		WithOptionOnTerminated(nil),
	} {
		_ = opt(cc)
	}

	return cc
}
